/*
    Shellcode and Exploit Detection Rules
    Detection of common shellcode patterns, exploit techniques, and payloads
*/

rule Shellcode_x86_GetPC {
    meta:
        description = "x86 shellcode GetPC (Position Independent Code)"
        severity = "critical"
        author = "AI-Cerberus"
    strings:
        $getpc1 = { E8 00 00 00 00 }                     // call $+5
        $getpc2 = { E8 FF FF FF FF C3 }                  // call $+0; ret
        $getpc3 = { D9 EE D9 74 24 F4 }                  // fldz; fstenv [esp-12]
        $getpc4 = { 64 8B 0D 00 00 00 00 }              // mov ecx, fs:[0]
        $getpc5 = { 31 C9 F7 E1 }                        // xor ecx,ecx; mul ecx
    condition:
        any of them
}

rule Shellcode_x64_GetPC {
    meta:
        description = "x64 shellcode GetPC patterns"
        severity = "critical"
    strings:
        $getpc1 = { 48 8D 05 00 00 00 00 }              // lea rax, [rip+0]
        $getpc2 = { 48 8B 05 00 00 00 00 }              // mov rax, [rip+0]
        $getpc3 = { E8 00 00 00 00 48 }                  // call $+5; pop rax
        $getpc4 = { 65 48 8B 04 25 60 00 00 00 }        // mov rax, gs:[0x60] (PEB)
    condition:
        any of them
}

rule Shellcode_API_Hashing {
    meta:
        description = "API hashing shellcode technique"
        severity = "critical"
    strings:
        // ROR13 hash calculation (common in Metasploit)
        $ror13_1 = { C1 CF 0D 03 F8 }                   // ror edi, 0xd; add edi, eax
        $ror13_2 = { C1 C7 0D 01 C7 }                   // rol edi, 0xd; add edi, eax

        // DJB2 hash
        $djb2 = { 6B C0 21 }                            // imul eax, 33

        // sdbm hash
        $sdbm = { C1 E0 06 01 D0 C1 E2 10 }

        // CRC32 variations
        $crc32 = { F7 D0 D1 E8 35 }

        // Common hash values
        $kernel32_hash = { 92 4E 7E 72 }               // kernel32.dll ROR13
        $loadlib_hash = { EC 08 26 89 }                // LoadLibraryA ROR13
        $getproc_hash = { 49 DA 8E 7A }                // GetProcAddress ROR13
    condition:
        any of ($ror13*, $djb2, $sdbm, $crc32) or 2 of ($*_hash)
}

rule Shellcode_PEB_Walk {
    meta:
        description = "PEB walking shellcode for API resolution"
        severity = "critical"
    strings:
        // x86 PEB access
        $peb32_1 = { 64 A1 30 00 00 00 }               // mov eax, fs:[0x30]
        $peb32_2 = { 64 8B 35 30 00 00 00 }            // mov esi, fs:[0x30]
        $peb32_3 = { 31 C0 64 8B 40 30 }               // xor eax,eax; mov eax, fs:[eax+0x30]

        // x64 PEB access
        $peb64_1 = { 65 48 8B 04 25 60 00 00 00 }     // mov rax, gs:[0x60]
        $peb64_2 = { 65 4C 8B 04 25 60 00 00 00 }     // mov r8, gs:[0x60]

        // LDR data structure walking
        $ldr1 = { 8B 40 0C 8B 40 14 }                  // mov eax,[eax+0xc]; mov eax,[eax+0x14]
        $ldr2 = { 8B 40 0C 8B 70 1C }                  // InMemoryOrderModuleList

        // x64 LDR
        $ldr64 = { 48 8B 48 18 48 8B 51 20 }
    condition:
        any of ($peb*) and any of ($ldr*)
}

rule Shellcode_Egg_Hunter {
    meta:
        description = "Egg hunter shellcode"
        severity = "critical"
    strings:
        // NtAccessCheckAndAuditAlarm egg hunter
        $egg1 = { 6A 21 58 CD 2E 3C 05 5A 74 }

        // NtDisplayString egg hunter
        $egg2 = { 66 81 CA FF 0F 42 52 6A 02 58 CD 2E }

        // SEH based egg hunter
        $egg3 = { EB 21 59 B8 74 30 30 77 }

        // Generic egg patterns
        $egg_marker = { 77 30 30 74 77 30 30 74 }     // w00tw00t
        $egg_marker2 = { 90 50 90 50 90 50 90 50 }
    condition:
        any of ($egg*) or $egg_marker or $egg_marker2
}

rule Shellcode_Socket_Operations {
    meta:
        description = "Socket shellcode for reverse/bind shells"
        severity = "critical"
    strings:
        // WSAStartup setup
        $wsa1 = { 68 01 01 }                           // push 0x101 (version)
        $wsa2 = { 54 50 29 40 52 }                     // WSAStartup call pattern

        // socket() call
        $socket1 = { 6A 06 6A 01 6A 02 }              // push 6,1,2 (TCP/STREAM/AF_INET)

        // connect() with IP/port
        $connect1 = { 68 ?? ?? ?? ?? 66 68 ?? ?? 66 6A 02 }  // sockaddr_in

        // bind() and listen()
        $bind1 = { 6A 10 56 57 }                       // bind(s, &sa, 16)
        $listen1 = { 6A 01 57 }                        // listen(s, 1)

        // Common ports in little endian
        $port443 = { 01 BB }                           // 443
        $port4444 = { 5C 11 }                          // 4444
        $port8080 = { 90 1F }                          // 8080
    condition:
        (any of ($wsa*) and any of ($socket*)) or
        (any of ($connect*, $bind*) and any of ($port*))
}

rule Shellcode_Process_Injection {
    meta:
        description = "Process injection shellcode patterns"
        severity = "critical"
    strings:
        // CreateRemoteThread injection
        $inject1 = { FF D5 89 C3 57 57 68 00 }        // call; mov; push patterns

        // NtCreateThreadEx
        $inject2 = { B8 C1 00 00 00 }                 // mov eax, 0xC1 (syscall)

        // Queue APC injection
        $inject3 = { B8 45 00 00 00 }                 // NtQueueApcThread

        // VirtualAllocEx + WriteProcessMemory pattern
        $inject4 = { 6A 40 68 00 30 00 00 }          // PAGE_EXECUTE_READWRITE, MEM_COMMIT|MEM_RESERVE

        // SetThreadContext (thread hijacking)
        $inject5 = { 68 10 00 01 00 }                // CONTEXT_FULL
    condition:
        any of them
}

rule Shellcode_Encoder_XOR {
    meta:
        description = "XOR encoded shellcode"
        severity = "high"
    strings:
        // XOR decoder stub patterns
        $xor1 = { 31 ?? EB ?? 5? 31 ?? 83 ?? ?? 74 }
        $xor2 = { 80 3? ?? 74 ?? 80 ?? ?? ?? E? }
        $xor3 = { FE C? 75 ?? E8 }

        // FNSTENV XOR decoder
        $fnstenv = { D9 74 24 F4 5? 29 C9 B1 }

        // Shikata ga nai (polymorphic XOR)
        $shikata = { D9 74 24 F4 5? 2B C9 B1 ?? 83 }
    condition:
        any of them
}

rule Shellcode_Encoder_Alpha {
    meta:
        description = "Alphanumeric encoded shellcode"
        severity = "high"
    strings:
        // Alpha2 encoder markers
        $alpha1 = "TYIIIIIIIIIIIIII" ascii
        $alpha2 = "VTX30VX4AP0A3HH0" ascii
        $alpha3 = "PYIIIIIIIIIIQZVD" ascii

        // Unicode-safe shellcode
        $unicode1 = { 00 56 00 54 00 58 00 }

        // Mixed case alpha
        $mixed = /[A-Za-z0-9]{50,}/ ascii
    condition:
        any of ($alpha*) or $unicode1
}

rule Exploit_ROP_Gadgets {
    meta:
        description = "ROP gadget chain indicators"
        severity = "critical"
    strings:
        // Common ROP gadgets
        $rop1 = { C3 }                                // ret
        $rop2 = { 5D C3 }                             // pop ebp; ret
        $rop3 = { 58 C3 }                             // pop eax; ret
        $rop4 = { 5B C3 }                             // pop ebx; ret
        $rop5 = { 59 C3 }                             // pop ecx; ret
        $rop6 = { 5A C3 }                             // pop edx; ret
        $rop7 = { 94 C3 }                             // xchg eax, esp; ret
        $rop8 = { C9 C3 }                             // leave; ret

        // Stack pivot
        $pivot1 = { 94 C3 }                           // xchg esp, eax; ret
        $pivot2 = { 87 E4 C3 }                        // xchg esp, eax (variant)

        // x64 ROP
        $rop64_1 = { 5F C3 }                          // pop rdi; ret
        $rop64_2 = { 5E C3 }                          // pop rsi; ret
    condition:
        5 of ($rop*) or any of ($pivot*)
}

rule Exploit_Stack_Spray {
    meta:
        description = "Stack/Heap spray patterns"
        severity = "high"
    strings:
        // NOP sleds
        $nop1 = { 90 90 90 90 90 90 90 90 90 90 }
        $nop2 = { 0C 0C 0C 0C 0C 0C 0C 0C }          // 0x0c0c0c0c
        $nop3 = { 0D 0D 0D 0D 0D 0D 0D 0D }          // 0x0d0d0d0d
        $nop4 = { 41 41 41 41 41 41 41 41 }          // AAAAAAAA

        // Heap spray in JavaScript
        $js1 = "unescape" ascii
        $js2 = "%u" ascii
        $js3 = "spray" ascii nocase
        $js4 = "while" ascii

        // Spray size indicators
        $size1 = "0x1000" ascii
        $size2 = "0x10000" ascii
    condition:
        any of ($nop*) or (2 of ($js*) and any of ($size*))
}

rule Exploit_ASLR_Bypass {
    meta:
        description = "ASLR bypass techniques"
        severity = "critical"
    strings:
        // Memory leak gadgets
        $leak1 = "NtQuerySystemInformation" ascii
        $leak2 = "NtQueryVirtualMemory" ascii
        $leak3 = "GetModuleHandleA" ascii
        $leak4 = "GetProcAddress" ascii

        // Non-ASLR modules (legacy)
        $noaslr1 = "msvcrt.dll" ascii nocase
        $noaslr2 = "ntdll.dll" ascii nocase

        // Info leak
        $infoleak = "VirtualQuery" ascii
    condition:
        3 of ($leak*) or (any of ($noaslr*) and $infoleak)
}

rule Exploit_DEP_Bypass {
    meta:
        description = "DEP bypass techniques"
        severity = "critical"
    strings:
        // VirtualProtect to make memory executable
        $vp1 = "VirtualProtect" ascii
        $vp2 = { 68 40 00 00 00 }                    // PAGE_EXECUTE_READWRITE

        // VirtualAlloc with RWX
        $va1 = "VirtualAlloc" ascii
        $va2 = { 68 40 00 00 00 68 00 30 00 00 }    // PAGE_EXECUTE_RW, MEM_COMMIT|RESERVE

        // NtProtectVirtualMemory
        $nt1 = "NtProtectVirtualMemory" ascii

        // SetProcessDEPPolicy (disable DEP)
        $dep1 = "SetProcessDEPPolicy" ascii

        // WriteProcessMemory to executable region
        $wpm = "WriteProcessMemory" ascii
    condition:
        ($vp1 and $vp2) or ($va1 and $va2) or $nt1 or $dep1 or ($vp1 and $wpm)
}

rule Exploit_Kernel_Shellcode {
    meta:
        description = "Kernel-mode shellcode patterns"
        severity = "critical"
    strings:
        // Token stealing
        $token1 = { 65 48 8B 04 25 88 01 00 00 }    // gs:[0x188] (KTHREAD)
        $token2 = { 48 8B 80 B8 00 00 00 }          // EPROCESS
        $token3 = { 48 8B 88 ?? 03 00 00 }          // Token offset

        // System process PID (4)
        $system_pid = { 83 B8 ?? ?? 00 00 04 }       // cmp [rax+offset], 4

        // ActiveProcessLinks walking
        $apl = { 48 8B 80 ?? 02 00 00 }

        // Token replacement
        $token_replace = { 48 89 88 ?? 03 00 00 }
    condition:
        any of ($token*) and ($system_pid or $apl or $token_replace)
}

rule Exploit_Browser_Spray {
    meta:
        description = "Browser exploit heap spray"
        severity = "critical"
    strings:
        $js1 = "ArrayBuffer" ascii
        $js2 = "DataView" ascii
        $js3 = "Uint8Array" ascii
        $js4 = "Uint32Array" ascii
        $spray1 = "spray" ascii nocase
        $spray2 = "fill" ascii
        $size = /0x[0-9a-fA-F]{4,8}/ ascii
    condition:
        2 of ($js*) and any of ($spray*) and $size
}

rule Exploit_Use_After_Free {
    meta:
        description = "Use-after-free exploitation patterns"
        severity = "critical"
    strings:
        // Object allocation/deallocation
        $alloc1 = "HeapAlloc" ascii
        $alloc2 = "HeapFree" ascii
        $alloc3 = "RtlAllocateHeap" ascii
        $alloc4 = "RtlFreeHeap" ascii

        // Spray patterns
        $spray = { 41 41 41 41 }

        // Type confusion
        $vftable = "vtable" ascii nocase
    condition:
        (all of ($alloc1, $alloc2) or all of ($alloc3, $alloc4)) and ($spray or $vftable)
}

rule Exploit_PDF_JavaScript {
    meta:
        description = "Malicious PDF with JavaScript exploit"
        severity = "high"
    strings:
        $pdf = "%PDF" ascii
        $js1 = "/JavaScript" ascii
        $js2 = "/JS" ascii
        $action = "/OpenAction" ascii
        $launch = "/Launch" ascii
        $encoded = "eval" ascii
        $heap = "unescape" ascii
    condition:
        $pdf at 0 and (($js1 or $js2) and ($action or $launch)) and any of ($encoded, $heap)
}

rule Exploit_Office_Macro {
    meta:
        description = "Malicious Office document with macros"
        severity = "high"
    strings:
        // VBA markers
        $vba1 = "AutoOpen" ascii nocase
        $vba2 = "Auto_Open" ascii nocase
        $vba3 = "Document_Open" ascii nocase
        $vba4 = "Workbook_Open" ascii nocase

        // Suspicious functions
        $func1 = "Shell" ascii
        $func2 = "WScript.Shell" ascii
        $func3 = "PowerShell" ascii nocase
        $func4 = "CreateObject" ascii
        $func5 = "Environ" ascii

        // Download
        $dl1 = "URLDownloadToFile" ascii
        $dl2 = "XMLHTTP" ascii
        $dl3 = "WinHttp" ascii
    condition:
        any of ($vba*) and (2 of ($func*) or any of ($dl*))
}
